# 09-响应式图片

> 用 `srcset` 和 `<picture>` 实现响应式图片.

---

## 分辨率切换: 不同尺寸

可以使用两个属性 — `srcset` and `sizes` — 提供多个源图和提示, 帮助浏览器选择正确的图片.

```html
<img
  srcset="elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w"
  sizes="(max-width: 600px) 480px,
         800px"
  src="elva-fairy-800w.jpg"
  alt="Elva dressed as a fairy">
```

属性 `srcset` 定义了可供浏览器选择的图片集, 以及每张图片的尺寸. 每组图片信息之间用逗号隔开. 对于每张图片, 我们需要写:

1. 一个**文件名** (`elva-fairy-480w.jpg`).
2. 一个**空格**.
3. 以像素为单位的**图片固有宽度** (`480w`) — 注意这里使用单位 `w`, 而不是 `px`. 图片的固有宽度是其真实尺寸.

属性 `sizes` 定义了一组媒体条件 (例如屏幕宽度), 且指明当这些媒体条件为真时, 什么图片尺寸会被采用. 上例中, 在每个逗号前我们写:

1. 一个**媒体条件** (`(max-width:600px)`) — 媒体条件描述了屏幕可能处于的状态. 本例中, 我们描述的是 *当视口宽度小于或等于 600 像素*.
2. 一个**空格**.
3. 当媒体条件为真时, 图片将填充的**槽的宽度** (`480px`).

> ⚠️: 对于槽的宽度, 你可能会提供一个固定值 (如 `480px`), 或者是相对于视口的宽度 (如 `50vw`) — 但不能是百分比. 注意最后一个槽的宽度没有媒体条件 (当其前面的媒体条件都为假时, 他默认生效). 当浏览器成功匹配第一个媒体条件时, 剩下所有的条件都会被忽略, 所以要注意媒体条件的顺序.

有了这些属性后, 浏览器会:

1. 检查设备宽度.
2. 找出 `sizes` 列表中第一个为真的媒体条件.
3. 查看对应的槽的宽度.
4. 加载 `srcset` 列表中与槽的宽度相同的图片. 如果没有, 就加载第一个比槽的宽度大的图片.

不支持这些特性的旧版本浏览器, 会忽略这些属性, 并按常规加载 `src` 属性引用的图片.

---

## 分辨率切换: 相同尺寸, 不同分辨率

如果你要支持多种显示分辨率, 但用户在屏幕上看到的图片实际尺寸相同, 你可以使用 `srcset` 和 `x`-descriptor, 让浏览器选择合适分辨率的图片, 而不用 `sizes` 属性.

```html
<style>
  /* 在本例中, 我们对图片应用了以下 CSS, 使其在屏幕上的宽度为 320 像素 (也称为 CSS 像素) */
  img {
      width: 320px;
  }
</style>

<img
  srcset="elva-fairy-320w.jpg, elva-fairy-480w.jpg 1.5x, elva-fairy-640w.jpg 2x"
  src="elva-fairy-640w.jpg"
  alt="Elva dressed as a fairy">
```

如果设备具有标准/低分辨率显示器, 每个设备像素表示一个 CSS 像素, 则将加载图片 `elva-fairy-320w.jpg` (`1x` 是隐含的, 所以不需要写出). 如果设备有高分辨率, 用两个或更多设备像素表示一个 CSS 像素, 则将加载图片 `elva-fairy-640w.jpg`.

---

## 美术方向

**美术方向问题** 涉及更改显示的图片以适应不同的显示尺寸. 例如在桌面浏览器上, 页面上有一个大的横向图片, 中间有一个人. 但当在手机浏览器上查看时, 该图片会被缩小, 导致图片中的人物变得很小, 难以看清. 这时, 显示一张更小的纵向图片可能会更好, 可放大人物. 元素 `<picture>` 允许我们实现这种解决方案.

```html
<picture>
    <source media="(max-width: 799px)" srcset="elva-480w-close-portrait.jpg">
    <source media="(min-width: 800px)" srcset="elva-800w.jpg">
    <img src="elva-800w.jpg" alt="Chris standing up holding his daughter Elva">
</picture>
```

> ⚠️: 只应在美术方向的场景中使用 `media` 属性. 当使用 `media` 属性时, 不要在 `sizes` 属性中也提供媒体条件.

---

## 为什么不用 CSS 或 JavaScript 来实现?

当浏览器开始加载一个页面, 他会在主解析器加载和解析 CSS 和 JavaScript 之前开始下载 (预加载) 所有图片. 该机制对于减少页面加载时间有用, 但对响应式图片无用. 例如, 你无法先加载 `<img>` 元素, 然后再用 JavaScript 检测视口宽度, 然后再根据需要动态地将源图改为较小的图片. 因为到那时, 原始图片已经被加载, 并且你还将再去加载小图片, 这会导致额外的加载时间和带宽.

---

?> {docsify-updated}